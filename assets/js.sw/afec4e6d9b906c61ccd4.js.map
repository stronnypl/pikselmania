{"version":3,"sources":["webpack://modern-prestashop-build-tool/./node_modules/swiper/modules/free-mode/free-mode.js"],"names":[],"mappings":"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","file":"js/afec4e6d9b906c61ccd4.js","sourcesContent":["import { now } from '../../shared/utils.js';\nexport default function freeMode(_ref) {\n  let {\n    swiper,\n    extendParams,\n    emit,\n    once\n  } = _ref;\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02\n    }\n  });\n\n  function onTouchStart() {\n    const translate = swiper.getTranslate();\n    swiper.setTranslate(translate);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({\n      currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n    });\n  }\n\n  function onTouchMove() {\n    const {\n      touchEventsData: data,\n      touches\n    } = swiper; // Velocity\n\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime\n      });\n    }\n\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now()\n    });\n  }\n\n  function onTouchEnd(_ref2) {\n    let {\n      currentPos\n    } = _ref2;\n    const {\n      params,\n      $wrapperEl,\n      rtlTranslate: rtl,\n      snapGrid,\n      touchEventsData: data\n    } = swiper; // Time diff\n\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n\n      return;\n    }\n\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n\n        newPosition = -newPosition;\n      }\n\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(() => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            $wrapperEl.transitionEnd(() => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd\n    }\n  });\n}"],"sourceRoot":""}